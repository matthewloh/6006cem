{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Classification\"\n",
        "format:\n",
        "  pdf:\n",
        "    toc: true\n",
        "    colorlinks: true\n",
        "    \n",
        "  html:\n",
        "    code-fold: false\n",
        "jupyter: python3\n",
        "author: \"Matthew Loh\"\n",
        "---"
      ],
      "id": "e07e412c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import pandas as pd\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.impute import SimpleImputer\n",
        "from sklearn.compose import ColumnTransformer\n",
        "from sklearn.pipeline import Pipeline\n",
        "from sklearn.linear_model import LinearRegression, LogisticRegression\n",
        "from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\n",
        "from sklearn.metrics import (\n",
        "    mean_squared_error,\n",
        "    r2_score,\n",
        "    accuracy_score,\n",
        "    classification_report,\n",
        ")\n",
        "from sklearn.model_selection import GridSearchCV\n",
        "\n",
        "\n",
        "class MLBackend:\n",
        "    def __init__(self, problem_type):\n",
        "        self.problem_type = problem_type  # 'regression' or 'classification'\n",
        "        self.data = None\n",
        "        self.X = None\n",
        "        self.y = None\n",
        "        self.X_train = None\n",
        "        self.X_test = None\n",
        "        self.y_train = None\n",
        "        self.y_test = None\n",
        "        self.model = None\n",
        "        self.preprocessor = None\n",
        "\n",
        "    def load_data(self, file_path):\n",
        "        # Load your dataset here\n",
        "        self.data = pd.read_csv(file_path)  # Adjust based on your data format\n",
        "        print(\"Data loaded. Shape:\", self.data.shape)\n",
        "\n",
        "    def preprocess_data(self):\n",
        "        # Identify features and target\n",
        "        self.X = self.data.drop(\n",
        "            \"target_column\", axis=1\n",
        "        )  # Replace 'target_column' with your actual target column name\n",
        "        self.y = self.data[\"target_column\"]\n",
        "\n",
        "        # Split the data\n",
        "        self.X_train, self.X_test, self.y_train, self.y_test = train_test_split(\n",
        "            self.X, self.y, test_size=0.2, random_state=42\n",
        "        )\n",
        "\n",
        "        # Create preprocessing steps\n",
        "        numeric_features = self.X.select_dtypes(include=[\"int64\", \"float64\"]).columns\n",
        "        categorical_features = self.X.select_dtypes(include=[\"object\"]).columns\n",
        "\n",
        "        numeric_transformer = Pipeline(\n",
        "            steps=[\n",
        "                (\"imputer\", SimpleImputer(strategy=\"median\")),\n",
        "                (\"scaler\", StandardScaler()),\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        categorical_transformer = Pipeline(\n",
        "            steps=[\n",
        "                (\"imputer\", SimpleImputer(strategy=\"constant\", fill_value=\"missing\")),\n",
        "                # Add one-hot encoding or other categorical encoding here\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        self.preprocessor = ColumnTransformer(\n",
        "            transformers=[\n",
        "                (\"num\", numeric_transformer, numeric_features),\n",
        "                (\"cat\", categorical_transformer, categorical_features),\n",
        "            ]\n",
        "        )\n",
        "\n",
        "        # Fit and transform the training data\n",
        "        self.X_train = self.preprocessor.fit_transform(self.X_train)\n",
        "        self.X_test = self.preprocessor.transform(self.X_test)\n",
        "\n",
        "        print(\"Data preprocessed.\")\n",
        "\n",
        "    def train_model(self):\n",
        "        if self.problem_type == \"regression\":\n",
        "            models = {\n",
        "                \"Linear Regression\": LinearRegression(),\n",
        "                \"Random Forest Regression\": RandomForestRegressor(random_state=42),\n",
        "            }\n",
        "        else:  # classification\n",
        "            models = {\n",
        "                \"Logistic Regression\": LogisticRegression(random_state=42),\n",
        "                \"Random Forest Classification\": RandomForestClassifier(random_state=42),\n",
        "            }\n",
        "\n",
        "        best_score = float(\"-inf\")\n",
        "        for name, model in models.items():\n",
        "            model.fit(self.X_train, self.y_train)\n",
        "            if self.problem_type == \"regression\":\n",
        "                score = r2_score(self.y_test, model.predict(self.X_test))\n",
        "            else:\n",
        "                score = accuracy_score(self.y_test, model.predict(self.X_test))\n",
        "\n",
        "            print(f\"{name} - Score: {score}\")\n",
        "            if score > best_score:\n",
        "                best_score = score\n",
        "                self.model = model\n",
        "\n",
        "        print(f\"Best model: {type(self.model).__name__}\")\n",
        "\n",
        "    def tune_model(self):\n",
        "        if isinstance(self.model, (RandomForestRegressor, RandomForestClassifier)):\n",
        "            param_grid = {\n",
        "                \"n_estimators\": [100, 200, 300],\n",
        "                \"max_depth\": [None, 10, 20, 30],\n",
        "                \"min_samples_split\": [2, 5, 10],\n",
        "                \"min_samples_leaf\": [1, 2, 4],\n",
        "            }\n",
        "        elif isinstance(self.model, LogisticRegression):\n",
        "            param_grid = {\n",
        "                \"C\": [0.1, 1, 10],\n",
        "                \"penalty\": [\"l1\", \"l2\"],\n",
        "                \"solver\": [\"liblinear\", \"saga\"],\n",
        "            }\n",
        "        else:  # LinearRegression\n",
        "            print(\"Linear Regression doesn't have hyperparameters to tune.\")\n",
        "            return\n",
        "\n",
        "        grid_search = GridSearchCV(\n",
        "            self.model,\n",
        "            param_grid,\n",
        "            cv=5,\n",
        "            scoring=\"r2\" if self.problem_type == \"regression\" else \"accuracy\",\n",
        "        )\n",
        "        grid_search.fit(self.X_train, self.y_train)\n",
        "        self.model = grid_search.best_estimator_\n",
        "        print(\"Model tuned. Best parameters:\", grid_search.best_params_)\n",
        "\n",
        "    def evaluate_model(self):\n",
        "        y_pred = self.model.predict(self.X_test)\n",
        "        if self.problem_type == \"regression\":\n",
        "            mse = mean_squared_error(self.y_test, y_pred)\n",
        "            r2 = r2_score(self.y_test, y_pred)\n",
        "            print(f\"Mean Squared Error: {mse}\")\n",
        "            print(f\"R2 Score: {r2}\")\n",
        "        else:\n",
        "            accuracy = accuracy_score(self.y_test, y_pred)\n",
        "            print(f\"Accuracy: {accuracy}\")\n",
        "            print(\"Classification Report:\")\n",
        "            print(classification_report(self.y_test, y_pred))\n",
        "\n",
        "\n",
        "# Usage example\n",
        "if __name__ == \"__main__\":\n",
        "    # For regression\n",
        "    regression_backend = MLBackend(\"regression\")\n",
        "    regression_backend.load_data(\"path_to_regression_data.csv\")\n",
        "    regression_backend.preprocess_data()\n",
        "    regression_backend.train_model()\n",
        "    regression_backend.tune_model()\n",
        "    regression_backend.evaluate_model()\n",
        "\n",
        "    # For classification\n",
        "    classification_backend = MLBackend(\"classification\")\n",
        "    classification_backend.load_data(\"path_to_classification_data.csv\")\n",
        "    classification_backend.preprocess_data()\n",
        "    classification_backend.train_model()\n",
        "    classification_backend.tune_model()\n",
        "    classification_backend.evaluate_model()"
      ],
      "id": "448bee52",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "c:\\Users\\matth\\6006cem\\.venv\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}